# LLM DSL 练习题集

## 基础练习 (Basic Level)

### 练习1: 简单问答
**目标**: 掌握最基本的DSL用法
```kotlin
// 任务: 使用DeepSeek模型询问"什么是Kotlin协程？"
// 要求: 使用 llm(llmService) { } 语法
```

### 练习2: 对话构建
**目标**: 学习使用chat功能构建对话
```kotlin
// 任务: 创建一个对话，包含：
// 1. 系统消息: "你是一个Kotlin专家"
// 2. 用户消息: "协程和线程有什么区别？"
// 3. 助手回复: "协程是轻量级的..."
// 4. 用户续问: "协程如何处理异常？"
```

### 练习3: 配置模型参数
**目标**: 学习配置temperature、maxTokens等参数
```kotlin
// 任务: 创建一个配置，要求：
// - 使用OpenAI GPT-4模型
// - temperature设为0.3（更保守的回答）
// - maxTokens设为500
// - 询问"请简洁地解释什么是设计模式"
```

## 中级练习 (Intermediate Level)

### 练习4: 流式响应
**目标**: 实现实时流式输出
```kotlin
// 任务: 实现一个流式响应，要求：
// 1. 请求LLM写一篇关于"人工智能发展历史"的短文
// 2. 实时打印每个chunk
// 3. 统计总字符数
// 4. 计算生成耗时
```

### 练习5: 错误处理和重试
**目标**: 配置弹性机制
```kotlin
// 任务: 创建一个具有弹性的LLM配置：
// 1. 最大重试3次
// 2. 使用指数退避策略（初始延迟1秒）
// 3. 超时时间30秒
// 4. 熔断器阈值为5次失败
// 模拟网络不稳定情况下的使用
```

### 练习6: 模型回退策略
**目标**: 实现多模型备份
```kotlin
// 任务: 配置主备模型：
// 主模型: OpenAI GPT-4
// 备用模型1: Anthropic Claude
// 备用模型2: DeepSeek Chat
// 测试当主模型失败时的自动切换
```

### 练习7: 上下文窗口管理
**目标**: 处理长对话的上下文管理
```kotlin
// 任务: 创建一个长对话场景：
// 1. 设置最大token数为1000
// 2. 使用滑动窗口策略
// 3. 进行10轮以上的对话
// 4. 观察上下文如何被管理
```

## 高级练习 (Advanced Level)

### 练习8: 函数调用 - 天气查询
**目标**: 实现工具集成
```kotlin
// 任务: 创建一个天气查询工具：
// 1. 定义WeatherRequest和WeatherResponse数据类
// 2. 实现getCurrentWeather函数
// 3. 让LLM能够调用这个函数
// 4. 测试："请查询北京的天气情况"

@Serializable
data class WeatherRequest(val city: String)

@Serializable  
data class WeatherResponse(
    val city: String,
    val temperature: Double,
    val description: String,
    val humidity: Int
)
```

### 练习9: 类型安全响应 - 结构化数据
**目标**: 获取结构化的JSON响应
```kotlin
// 任务: 让LLM返回结构化的旅行计划：
// 1. 定义TravelPlan数据类
// 2. 配置responseFormat
// 3. 请求制定"日本5天旅行计划，预算2万元"
// 4. 验证返回的数据类型

@Serializable
data class TravelPlan(
    val destination: String,
    val duration: Int,
    val budget: Double,
    val itinerary: List<DayPlan>,
    val estimatedCost: Double
)

@Serializable
data class DayPlan(
    val day: Int,
    val activities: List<String>,
    val meals: List<String>,
    val accommodation: String
)
```

### 练习10: 批量处理 - 文本分析
**目标**: 实现并发批量处理
```kotlin
// 任务: 批量分析多篇文章的情感：
// 1. 准备5-10篇不同情感的文本
// 2. 配置并发数为3
// 3. 设置速率限制（每分钟最多10个请求）
// 4. 批量分析每篇文章的情感（正面/负面/中性）
// 5. 统计处理时间和成功率

val articles = listOf(
    "今天天气真好，心情愉快...",
    "这部电影太糟糕了...",
    "技术文档：如何使用Kotlin...",
    // ... 更多文章
)
```

## 实战项目练习 (Project Level)

### 练习11: 智能客服系统
**目标**: 构建一个完整的客服机器人
```kotlin
// 任务: 实现一个客服系统，包含：
// 1. 上下文管理（记住用户历史问题）
// 2. 工具集成（查询订单、退款等）
// 3. 情感分析（识别用户情绪）
// 4. 自动升级（复杂问题转人工）
// 5. 多轮对话处理

// 需要实现的工具：
// - 订单查询工具
// - 退款处理工具  
// - 情感分析工具
// - 问题分类工具
```

### 练习12: 代码审查助手
**目标**: 创建AI代码审查工具
```kotlin
// 任务: 实现代码审查助手：
// 1. 接收代码片段
// 2. 分析代码质量（可读性、性能、安全性）
// 3. 提供具体的改进建议
// 4. 生成改进后的代码
// 5. 支持不同编程语言

// 示例输入：
val codeToReview = """
fun processUsers(users: List<User>): List<String> {
    val result = mutableListOf<String>()
    for (user in users) {
        if (user.isActive) {
            result.add(user.name.toUpperCase())
        }
    }
    return result
}
"""
```

### 练习13: 多模型投票系统
**目标**: 实现模型结果比较和投票
```kotlin
// 任务: 创建一个多模型投票系统：
// 1. 同时向3个不同模型提问
// 2. 比较它们的答案
// 3. 使用第4个模型作为"裁判"选出最佳答案
// 4. 记录各模型的表现统计
// 5. 实现动态模型权重调整

// 测试问题类型：
// - 事实性问题（有标准答案）
// - 创意性问题（主观评价）
// - 技术问题（需要准确性）
// - 分析性问题（需要逻辑）
```

## 进阶挑战 (Expert Level)

### 练习14: 自适应对话系统
**目标**: 根据用户特征调整对话策略
```kotlin
// 任务: 实现智能对话适配：
// 1. 分析用户的专业程度
// 2. 根据用户背景调整回答详细程度
// 3. 记住用户偏好（简洁 vs 详细）
// 4. 动态调整模型参数
// 5. 实现个性化的对话风格

// 用户类型识别：
// - 专家用户：技术术语、简洁回答
// - 初学者：详细解释、举例说明
// - 商务用户：重点突出、数据支撑
```

### 练习15: 智能内容生成流水线
**目标**: 构建内容创作工作流
```kotlin
// 任务: 实现内容生成流水线：
// 1. 主题研究（收集相关信息）
// 2. 大纲生成（结构化内容框架）
// 3. 内容撰写（分段生成详细内容）
// 4. 内容优化（语言润色、SEO优化）
// 5. 质量检查（事实核验、逻辑检查）

// 流水线步骤：
// 输入主题 -> 研究 -> 大纲 -> 撰写 -> 优化 -> 输出
```

## 实用提示

### 环境准备
1. 确保你有有效的API密钥
2. 查看项目中的 `llm-keys.md` 配置密钥
3. 运行基础测试确保环境正常

### 调试技巧
1. 使用较小的token限制进行测试
2. 先测试简单场景再增加复杂度
3. 启用日志查看详细执行过程
4. 使用mock provider测试错误处理

### 最佳实践
1. 合理设置重试和超时
2. 根据使用场景选择合适的模型
3. 注意API调用成本控制
4. 实现适当的错误处理和用户反馈

### 扩展学习
1. 尝试集成新的LLM提供商
2. 开发自定义工具和函数
3. 实现复杂的上下文管理策略
4. 探索多模态能力（如果支持）

开始练习时，建议按顺序完成，每个练习都包含了特定的学习目标。完成基础练习后，可以尝试组合不同特性来解决更复杂的问题。

记住：实践是最好的学习方式！